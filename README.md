# SHRI-2018-homework-11

### Домашняя работа по теме "Алгоритмы"

Яндекс. Школа разработки интерфейсов. 2018 год.

#### Задание 2: saggest

Для оптимизации взаимодействия с пользователем вызов saggest в коде происходит с timeout в 250ms, чтобы поиск не начинался при нажатии каждой клавиши, если человек еще не допечатал строку. Это время не входит в расчет времени работы функции. При необходимости его можно убрать.  
  
Для начала для поиска подстроки я попробовала использовать выражение:  
```
for (const street of streets) {
    ...
  street.match(new RegExp(substr, 'i'));
```
Для подстроки "теат" результат выдавался в среднем через 100-120 ms.  
Это слишком долго) Я попробовала другой метод:  
```
substr = substr.toLowerCase();

for (const street of streets) {
    ...
    street.toLowerCase().includes(substr);

```
Этот способ для той же подстроки выдавал результат за 5-8 ms.  
  
Для оптимизации поиска я попробовала разбить массив данных на отдельные кластеры и осуществлять по ним асинхронный поиск с одним общим счетчиком результатов. Когда найдено 10 подходящих строк, обход кластеров заканчивается, результаты собираются во фрагмент (document.fragment) и вставляются на страницу не по одному, а целым списком.  
Для усложнения поиска база улиц была продублирована 3 раза. Поэтому в выдаваемых результатах названия улиц могут повторяться, это не ошибка. Но все же, так как время выполнения уже очень мало, то погрешность большая и при поиске подстроки очень сложно понять уменьшилось ли время выполнения благодаря кластерам или нет - цифры скачут и очень разнятся. Но при поиске несуществующей строки (в данном случае это любая строка c латиницей), то есть в ситуации когда происходит полный обход всего массива, поиск по кластерам выдает лучшие результаты.  
Конечно, такой способ на самом деле должен задействовать сервер - данные должны быть разбиты на кластеры заранее и уже в таком виде отдаваться на клиент, иначе этот метод задействует очень много памяти из-за дублирования данных.
